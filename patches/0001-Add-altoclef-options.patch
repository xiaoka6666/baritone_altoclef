From 238fd5e965540e645cfbbc121ed0620e1453ab59 Mon Sep 17 00:00:00 2001
From: MiranCZ <miraancz@gmail.com>
Date: Sun, 27 Apr 2025 17:44:18 +0200
Subject: [PATCH 1/4] Add altoclef options

---
 .../baritone/altoclef/AltoClefSettings.java   | 272 ++++++++++++++++++
 1 file changed, 272 insertions(+)
 create mode 100644 src/main/java/baritone/altoclef/AltoClefSettings.java

diff --git a/src/main/java/baritone/altoclef/AltoClefSettings.java b/src/main/java/baritone/altoclef/AltoClefSettings.java
new file mode 100644
index 00000000..0404c61d
--- /dev/null
+++ b/src/main/java/baritone/altoclef/AltoClefSettings.java
@@ -0,0 +1,272 @@
+/*
+ * This file is part of Baritone.
+ *
+ * Baritone is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * Baritone is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with Baritone.  If not, see <https://www.gnu.org/licenses/>.
+ */
+
+package baritone.altoclef;
+
+import net.minecraft.core.BlockPos;
+import net.minecraft.world.item.Item;
+import net.minecraft.world.item.ItemStack;
+import net.minecraft.world.level.block.state.BlockState;
+
+import java.util.ArrayList;
+import java.util.HashSet;
+import java.util.List;
+import java.util.function.BiFunction;
+import java.util.function.BiPredicate;
+import java.util.function.Predicate;
+
+public class AltoClefSettings {
+
+    // woo singletons
+    private static AltoClefSettings _instance = new AltoClefSettings();
+    private final Object breakMutex = new Object();
+    private final Object placeMutex = new Object();
+    private final Object propertiesMutex = new Object();
+    private final Object globalHeuristicMutex = new Object();
+    private final HashSet<BlockPos> _blocksToAvoidBreaking = new HashSet<>();
+    private final List<Predicate<BlockPos>> _breakAvoiders = new ArrayList<>();
+    private final List<Predicate<BlockPos>> _placeAvoiders = new ArrayList<>();
+    private final List<Predicate<BlockPos>> _forceCanWalkOn = new ArrayList<>();
+    private final List<Predicate<BlockPos>> _forceAvoidWalkThrough = new ArrayList<>();
+    private final List<BiPredicate<BlockState, ItemStack>> _forceSaveTool = new ArrayList<>();
+    private final List<BiPredicate<BlockState, ItemStack>> _forceUseTool = new ArrayList<>();
+    private final List<BiFunction<Double, BlockPos, Double>> _globalHeuristics = new ArrayList<>();
+    private final HashSet<Item> _protectedItems = new HashSet<>();
+    private boolean _allowFlowingWaterPass;
+    private boolean _pauseInteractions;
+    private boolean _dontPlaceBucketButStillFall;
+    private boolean _allowSwimThroughLava = false;
+    private boolean _treatSoulSandAsOrdinaryBlock = false;
+    private boolean canWalkOnEndPortal = false;
+
+    public static AltoClefSettings getInstance() {
+        return _instance;
+    }
+
+    public void canWalkOnEndPortal(boolean canWalk) {
+        canWalkOnEndPortal = canWalk;
+    }
+
+    public void avoidBlockBreak(BlockPos pos) {
+        synchronized (breakMutex) {
+            _blocksToAvoidBreaking.add(pos);
+        }
+    }
+
+    public void avoidBlockBreak(Predicate<BlockPos> avoider) {
+        synchronized (breakMutex) {
+            _breakAvoiders.add(avoider);
+        }
+    }
+
+    public void configurePlaceBucketButDontFall(boolean allow) {
+        synchronized (propertiesMutex) {
+            _dontPlaceBucketButStillFall = allow;
+        }
+    }
+
+    public void treatSoulSandAsOrdinaryBlock(boolean enable) {
+        synchronized (propertiesMutex) {
+            _treatSoulSandAsOrdinaryBlock = enable;
+        }
+    }
+
+    public void avoidBlockPlace(Predicate<BlockPos> avoider) {
+        synchronized (placeMutex) {
+            _placeAvoiders.add(avoider);
+        }
+    }
+
+    public boolean shouldForceSaveTool(BlockState state, ItemStack tool) {
+        synchronized (propertiesMutex) {
+            return _forceSaveTool.stream().anyMatch(pred -> pred.test(state, tool));
+        }
+    }
+
+    public boolean shouldAvoidBreaking(int x, int y, int z) {
+        return shouldAvoidBreaking(new BlockPos(x, y, z));
+    }
+
+    public boolean shouldAvoidBreaking(BlockPos pos) {
+        synchronized (breakMutex) {
+            if (_blocksToAvoidBreaking.contains(pos))
+                return true;
+            return (_breakAvoiders.stream().anyMatch(pred -> pred.test(pos)));
+        }
+    }
+
+    public boolean shouldAvoidPlacingAt(BlockPos pos) {
+        synchronized (placeMutex) {
+            return _placeAvoiders.stream().anyMatch(pred -> pred.test(pos));
+        }
+    }
+
+    public boolean shouldAvoidPlacingAt(int x, int y, int z) {
+        return shouldAvoidPlacingAt(new BlockPos(x, y, z));
+    }
+
+    public boolean canWalkOnForce(int x, int y, int z) {
+        synchronized (propertiesMutex) {
+            return _forceCanWalkOn.stream().anyMatch(pred -> pred.test(new BlockPos(x, y, z)));
+        }
+    }
+
+    public boolean shouldAvoidWalkThroughForce(BlockPos pos) {
+        synchronized (propertiesMutex) {
+            return _forceAvoidWalkThrough.stream().anyMatch(pred -> pred.test(pos));
+        }
+    }
+
+    public boolean shouldAvoidWalkThroughForce(int x, int y, int z) {
+        return shouldAvoidWalkThroughForce(new BlockPos(x, y, z));
+    }
+
+    public boolean shouldForceUseTool(BlockState state, ItemStack tool) {
+        synchronized (propertiesMutex) {
+            return _forceUseTool.stream().anyMatch(pred -> pred.test(state, tool));
+        }
+    }
+
+    public boolean shouldNotPlaceBucketButStillFall() {
+        synchronized (propertiesMutex) {
+            return _dontPlaceBucketButStillFall;
+        }
+    }
+
+    public boolean shouldTreatSoulSandAsOrdinaryBlock() {
+        synchronized (propertiesMutex) {
+            return _treatSoulSandAsOrdinaryBlock;
+        }
+    }
+
+    public boolean isInteractionPaused() {
+        synchronized (propertiesMutex) {
+            return _pauseInteractions;
+        }
+    }
+
+    public void setInteractionPaused(boolean paused) {
+        synchronized (propertiesMutex) {
+            _pauseInteractions = paused;
+        }
+    }
+
+    public boolean isFlowingWaterPassAllowed() {
+        synchronized (propertiesMutex) {
+            return _allowFlowingWaterPass;
+        }
+    }
+
+    public boolean canSwimThroughLava() {
+        synchronized (propertiesMutex) {
+            return _allowSwimThroughLava;
+        }
+    }
+
+    public void setFlowingWaterPass(boolean pass) {
+        synchronized (propertiesMutex) {
+            _allowFlowingWaterPass = pass;
+        }
+    }
+
+    public void allowSwimThroughLava(boolean allow) {
+        synchronized (propertiesMutex) {
+            _allowSwimThroughLava = allow;
+        }
+    }
+
+    public double applyGlobalHeuristic(double prev, int x, int y, int z) {
+        return prev;
+        /*
+        synchronized (globalHeuristicMutex) {
+            BlockPos p = new BlockPos(x, y, z);
+            for (BiFunction<Double, BlockPos, Double> toApply : _globalHeuristics) {
+                prev = toApply.apply(prev, p);
+            }
+        }
+        return prev;
+         */
+    }
+
+    public HashSet<BlockPos> getBlocksToAvoidBreaking() {
+        return _blocksToAvoidBreaking;
+    }
+
+    public List<Predicate<BlockPos>> getBreakAvoiders() {
+        return _breakAvoiders;
+    }
+
+    public List<Predicate<BlockPos>> getPlaceAvoiders() {
+        return _placeAvoiders;
+    }
+
+    public List<Predicate<BlockPos>> getForceWalkOnPredicates() {
+        return _forceCanWalkOn;
+    }
+
+    public List<Predicate<BlockPos>> getForceAvoidWalkThroughPredicates() {
+        return _forceAvoidWalkThrough;
+    }
+
+    public List<BiPredicate<BlockState, ItemStack>> getForceSaveToolPredicates() {
+        return _forceSaveTool;
+    }
+
+    public List<BiPredicate<BlockState, ItemStack>> getForceUseToolPredicates() {
+        return _forceUseTool;
+    }
+
+    public List<BiFunction<Double, BlockPos, Double>> getGlobalHeuristics() {
+        return _globalHeuristics;
+    }
+
+    public boolean isItemProtected(Item item) {
+        return _protectedItems.contains(item);
+    }
+
+    public HashSet<Item> getProtectedItems() {
+        return _protectedItems;
+    }
+
+    public void protectItem(Item item) {
+        _protectedItems.add(item);
+    }
+
+    public void stopProtectingItem(Item item) {
+        _protectedItems.remove(item);
+    }
+
+    public Object getBreakMutex() {
+        return breakMutex;
+    }
+
+    public Object getPlaceMutex() {
+        return placeMutex;
+    }
+
+    public Object getPropertiesMutex() {
+        return propertiesMutex;
+    }
+
+    public Object getGlobalHeuristicMutex() {
+        return globalHeuristicMutex;
+    }
+
+    public boolean isCanWalkOnEndPortal() {
+        return canWalkOnEndPortal;
+    }
+}
\ No newline at end of file
-- 
2.45.1.windows.1

